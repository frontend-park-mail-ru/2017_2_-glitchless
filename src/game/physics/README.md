# Физика. Информация для разработчиков [rus]

Короче, Фронтэндер. Тут внутреняя документация по физике. Описания примитивов, межсерверного взаимодействия и всего такого. Пофиксишь пару багов — и мы в расчёте. Заодно посмотрим, как быстро у тебя башка после амнезии прояснится. А по твоей теме постараюсь разузнать. Хрен его знает, на кой ляд тебе этот Фронтэнд сдался. Но я в чужие дела не лезу. Хочешь упарываться — значит на то есть причины.

## Система позиционирования

Чтобы не запутаться к херам у нас есть две сетки координат и перевод из одной в другую происходит почти по волшебству (волшебством нынче называют метод `GameScene.scaleCoords`). Чтобы не было такого что открываешь игру на полный экран, а там физика поехала. Пока в проекте внутренние координаты равны [1920, 1080], а так думаем над [1080, 1080] для оптимизаций.

## Объекты

Для упрощения мы разделили все игровые на две части. Те которые можно двигать, и те которые двигать нельзя. Называются они PhysicsEntity и PhysicsObject соответсвенно. Чтобы бедные разработчики не мучались с `instanceof` есть флаг isStatic у обоих объектов. По задумке создателя это должно быть удобно

## Тик-система

Тиков два. Да. В одном UI тике два тика.

Первый тик - это вычисление векторов и, если нужно, подхватываем вектора из сервера (берем из очереди на обработку из вебсокета).

Второй тик вычисляет из вектора координаты. Вот тут поподробнее:
- Примитив вектор (точка) - это два значения, которые используются для извращенных желаний программистов
- Единица скорости в игре 1 физический пиксель в миллисекунду и 1 градус в миллисекунду. В нормальных языках (Java или Kotlin, например) для значений будет использоваться `float`

# Клиент-серверное взаимодействие
## Основное

У каждого объекта есть ID, выдаваемый сервером. В начале сессии все объекты отдаются клиенты и только после этого начинается сессия.

## Платформа и зарядка щита
![](https://i.imgur.com/ckxqPMW.jpg)
Введется коммит-система всех изменений на сервер для того, чтобы можно было применить изменения с учетом аппрувнутых изменений с сервера и неотправленных изменений с клиента.
Считается, что если сервер получил транзакцию N, транзакции < N уже отправлены. За счет чего можно чистить очередь.

Остальные игроки получают изменения и мгновенно применяют их (при этом предварительно они пытаются их предугадать)

Очереди и на клиенте и на сервере могут сплющивать одинаковые изменения. Например:
- Два коммита передвижения. Один на +12, второй на +24. В сумме получаем коммит на 36
- Два коммита с позицией и текущим вектором. Просто убираем более старый коммит.

## Лазеры

Для оптимизации будем отправлять только два события:
- Один из клиентов сказал что он отбил ракетку и сервер заапрувил это
- Выстрел из пришельца
- *Важные события*

Но возникают проблемы с тем, что клиент может неправильно додумать информацию. В данном случае таких изменений два:
- Повреждение щита
- Повреждение енергипоинта

Делаем следующее:
- Для каждого важного изменения с лазером (перечислены выше) записываем в мапу с {id, event}
- Если с сервера пришла другая инфа (т.е. лазер отбили) выполняется event.revert(). Если пришла инфа что все правильно сервер додумал, просто удаляем этот объект из мапы

## Конфликт интересов

Если пользователь думает что отбил ракетку, отправляется пакет на сервер. Там мы смотрим могло ли такое произойти. Если могло, коммитим информацию и отправляем всем клиентам.

Для простоты все пакеты на сервер будут помечаться ID. В случае с лазером смотрим мог ли отбиться лазер в промежутке между коммитом лазера (И) и предыдущем коммите (N-1). Соответственно, с клиента должна отправлятся точная информация о том как именно был отражен лазер

## Всякая всячина:
- Ссылка на дебаг версию PhysicLoop.js: https://gist.github.com/LionZXY/f318fcd89ebc25792399fdf1e7bde4bd